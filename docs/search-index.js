var N = null;var searchIndex = {};
searchIndex["mwgc"]={"doc":"A sesame-seed-sized heap with a tri-color, tracing, conservative, incremental, non-compacting garbage collector, for implementing a tiny language on tiny hardware.","items":[[3,"Heap","mwgc","Takes ownership of a block of `Memory`, hands out chunks of it, and garbage collects unused chunks on demand.",N,N],[3,"HeapStats","","Stats returned from `Heap::get_stats`.",N,N],[12,"total_bytes","","total bytes available in the heap: provided memory minus overhead",0,N],[12,"free_bytes","","bytes free for future allocations right now",0,N],[12,"start","","for testing & debugging: the extent of the pool",0,N],[12,"end","","for testing & debugging: the extent of the pool",0,N],[3,"Memory","","Wrapper for an owned, mutable chunk of memory.",N,N],[11,"new","","Create a new heap out of a mutable chunk of memory.",1,[[["memory"]],["heap"]]],[11,"from_bytes","","Create a new heap out of a mutable byte-slice.",1,N],[11,"allocate","","Request a `amount` bytes of memory. The size will be rounded up to a multiple of the block size. Returns `None` if a block of memory that big isn't available,",1,[[["self"],["usize"]],["option",["memory"]]]],[11,"allocate_object","","Request enough memory to hold an object of type `T`. The object will be initialized to its default value. Returns `None` if a block of memory that big isn't available.",1,[[["self"]],["option"]]],[11,"allocate_array","","Request enough memory to hold an array of `count` objects of type `T`. Each object in the array will be initialized to its default value. Returns `None` if a block of memory that big isn't available.",1,[[["self"],["usize"]],["option"]]],[11,"retire","","Give back an allocation without waiting for a GC round.",1,[[["self"],["memory"]]]],[11,"retire_object","","Give back an allocated object without waiting for a GC round.",1,[[["self"],["t"]]]],[11,"mark_start","","Start the first phase of garbage collection. This is only useful if you want tight control over latency -- otherwise, you should call `gc()`.",1,N],[11,"mark_round","","Do one \"round\" of the mark phase of garbage collection. This is only useful if you want tight control over latency -- otherwise, you should call `gc()`.",1,[[["self"]],["bool"]]],[11,"mark","","Do the mark phase of garbage collection (the first of two phases).",1,N],[11,"mark_check","","Mark an object to be re-checked because it's been modified during the mark phase of garbage collection.",1,[[["self"],["t"]]]],[11,"get_mark_range","","For debugging and tests, report the current range of addresses that will be scanned on the next `mark_round`.",1,N],[11,"sweep","","Sweep through the heap and move every un-marked span of memory into the free list. This is the 2nd and final phase of garbage collection.",1,[[["self"]]]],[11,"gc","","Do an entire GC round, freeing any currently unused memory.",1,N],[11,"dump","","For debugging: generate a string listing the size and color of each span of memory.",1,[[["self"]],["string"]]],[11,"dump_spans","","For debugging: generate a string listing only the color of each span of memory.",1,[[["self"]],["string"]]],[11,"get_stats","","Return an object listing the free & total bytes of this heap.",1,[[["self"]],["heapstats"]]],[11,"new","","Wrap a mutable slice of memory.",2,N],[11,"from_addresses","","Assuming you own a span of memory from the `start` address (inclusive) to the `end` address (exclusive), unsafely create a `Memory` wrapper for it.",2,N],[11,"split_at","","Equivalent to `slice::split_at_mut`.",2,N],[11,"clear","","Zero out this memory.",2,[[["self"]]]],[11,"inner","","Convert back into a mutable slice of memory, consuming this object.",2,N],[11,"len","","Size (in bytes).",2,[[["self"]],["usize"]]],[11,"start","","Starting address (inclusive).",2,N],[11,"end","","Ending address (exclusive).",2,N],[11,"into","","",1,[[["self"]],["u"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]]],"paths":[[3,"HeapStats"],[3,"Heap"],[3,"Memory"]]};
searchIndex["static_assertions"]={"doc":"Banner","items":[[14,"assert_cfg","static_assertions","Asserts that a given configuration is set.",N,N],[14,"assert_eq_size","","Asserts that types are equal in size.",N,N],[14,"assert_eq_size_ptr","","Asserts that values pointed to are equal in size.",N,N],[14,"assert_eq_size_val","","Asserts that values are equal in size.",N,N],[14,"assert_fields","","Asserts that the type has the given fields.",N,N],[14,"assert_impl","","Asserts that the type implements the given traits.",N,N],[14,"assert_obj_safe","","Asserts that the traits are [object-safe][object].",N,N],[14,"const_assert","","Asserts that constant expressions evaluate to `true`.",N,N],[14,"const_assert_eq","","Asserts that constants are equal in value.",N,N]],"paths":[]};
initSearch(searchIndex);
